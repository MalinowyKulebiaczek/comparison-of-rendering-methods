import os
from multiprocessing import Pool, Value
import time
import numpy as np
from tqdm import tqdm

from procedure import MainProcedure
from renders.collision import get_collision, calc_triangles
from utilities.bitmap import Bitmap
from utilities.ray import Ray

from renders.sampler import RandomSampler

"""
Comment by: Damian Łysomirski
I don't think this mapping is present, it is available for various samplers and we don't use them.
See:
https://en.wikipedia.org/wiki/Path_tracing
"""
process_procedure = None
intersections = None
shadow_rays = None

def init_worker(procedure: MainProcedure, intersection_count, shadow_rays_count):
    global process_procedure
    global intersections
    global shadow_rays

    if process_procedure is None:
        process_procedure = procedure
        process_procedure.load_scene()
        process_procedure.load_background()
        process_procedure.scene.load_objects()
        process_procedure.scene.load_materials()
        process_procedure.scene.load_lights()
        process_procedure.scene.load_camera()
    if intersections is None:
        intersections = intersection_count
    if shadow_rays is None:
        shadow_rays = shadow_rays_count


def increment_intersection_counter():
    with intersections.get_lock():
        intersections.value += 1

def increment_shadow_rays_counter():
    with shadow_rays.get_lock():
        shadow_rays.value += 1


def hemisphere_mapping(point: np.array, normal: np.array) -> np.array:
    if np.dot(point, normal) < 0:
        return -point
    else:
        return point


def random_three_vector():
    """
    Generates a random 3D unit vector (direction) with a uniform spherical distribution
    Algo from http://stackoverflow.com/questions/5408276/python-uniform-spherical-distribution
    :return:
    """
    u = np.random.random()
    v = np.random.random()

    theta = 2 * np.pi * u
    phi = np.arccos(2 * v - 1)

    x = np.sin(theta) * np.cos(phi)
    y = np.sin(theta) * np.sin(phi)
    z = np.cos(theta)

    return np.array([x, y, z])


def path_trace(procedure: MainProcedure) -> Bitmap:
    """
    Main procedure:

    creates bitmap, renders each pixel from corresponding
    ray generated by camera.
    """
    time_start = time.time()
    intersection_count = Value("i", 0)
    shadow_rays_count = Value("i", 0)
    init_worker(procedure=procedure, intersection_count=intersection_count, shadow_rays_count=shadow_rays_count)
    bitmap = Bitmap(*procedure.scene.camera.resolution)
    number_of_traingles = calc_triangles(procedure.scene)
    rays = procedure.scene.camera.generate_initial_rays()
    procedure.free_scene()
    np.random.shuffle(rays)

    with Pool(
        processes=os.cpu_count(),
        initializer=init_worker,
        initargs=(procedure, intersection_count, shadow_rays_count),
    ) as pool:
        with tqdm(total=len(rays), mininterval=2) as pbar:
            for ((x, y), color) in pool.imap_unordered(trace_ray_task, rays):
                bitmap[y, x] = color
                pbar.update()

    elapsed_time = time.time() - time_start

    #Statistics
    process_procedure.set_statistic("Number of triangles", number_of_traingles)
    process_procedure.set_statistic("Intersections", intersections.value)
    process_procedure.set_statistic("Number_of_shadow_rays", shadow_rays.value)
    process_procedure.set_statistic("Total_time", str(time.strftime("%H:%M:%S", time.gmtime(elapsed_time))))
    
    return bitmap


def trace_ray_task(batch):
    """
    Task executed in Pool.
    """

    samples = process_procedure.samples

    result = np.array([0.0, 0.0, 0.0])
    for _ in range(samples):
        result += trace_ray(process_procedure, batch[1])

    return (batch[0], (result / samples * 255).astype("uint8"))


def trace_ray(
    procedure: MainProcedure,
    ray: Ray,
    # sampler: RandomSampler, #Wydaje mi się
    depth: int = 0,
) -> np.array:
    """
    Trace ray
    """
    if depth > procedure.max_depth:
        return background(procedure, ray)

    hit = get_collision(ray, procedure.scene)

    if hit is None:
        return background(procedure, ray)
    else:
        increment_intersection_counter()

    new_ray = Ray(
        origin=hit.coords,
        direction=hemisphere_mapping(
            random_three_vector(), hit.normal
        ),  # Tu mi się wydaje ze moze blad być
    )

    probability = 1 / (2 * np.pi)

    hit_material = procedure.scene.get_material(hit.material_id)

    emmitance = hit_material.emmitance

    # if emmitance[0] > 0:
    #    return emmitance

    cos_theta = np.dot(new_ray.direction, hit.normal)

    """
    Na wikipedi jest inaczej z tym brdf ?
    """

    # brdf = (hit_material.diffusion * cos_theta) + (  # diffusion brdf
    #    hit_material.reflectance  # reflectance = specular w .dae
    #    * (np.dot(ray.direction, new_ray.direction) ** hit_material.shininess)
    # )  # reflectance brdf
    brdf = hit_material.reflectance / np.pi
    # brdf = hit_material.diffusion * np.max(cos_theta, 0)

    incoming = trace_ray(procedure, new_ray, depth + 1)

    direct_lighting = np.zeros(3)  # initialize empty direct lighting value
    for light in procedure.scene.lights:
        # calculate the direct lighting contribution from each light source
        light_direction = light.position - hit.coords
        light_distance = np.linalg.norm(light_direction)
        light_direction = light_direction / light_distance

        #Calc number of shadow rays
        shadow_ray = Ray(origin=hit.coords, direction=light_direction)
        increment_shadow_rays_counter()
        
        hit_between_object_and_light = get_collision(shadow_ray, procedure.scene)
        if hit_between_object_and_light is None or calculate_distance(
            hit.coords, hit_between_object_and_light.coords
        ) >= calculate_distance(hit.coords, light.position):
            # if there is no collision, the point is not in shadow
            # direct_lighting += (light.intensity / (light_distance ** 2)) * np.maximum(np.dot(light_direction, hit.normal), 0) * hit_material.diffusion
            direct_lighting += (
                hit_material.diffusion
                * np.dot(light_direction, hit.normal)
                * light_attenuation(light, hit)
            )

    # RENDER EQUATION
    return (incoming * brdf * cos_theta / probability) + direct_lighting


def background(
    procedure: MainProcedure,
    ray: Ray,
) -> np.array:
    """
    Gets environment map value for the ray
    or returns black other way
    """
    return procedure.background(ray)


def calculate_distance(p1, p2):
    squared_dist = np.sum((p1 - p2) ** 2, axis=0)
    return np.sqrt(squared_dist)


def light_attenuation(light, hit):
    # constant after / is for scaling the light's brightness
    return np.average(light.color) / (
        500 * np.linalg.norm(light.position - hit.coords) ** 2 + 1000
    )
